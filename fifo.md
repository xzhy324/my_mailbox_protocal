循环FIFO Mailbox设计（针对不满512K的小对象的传输效率高）

# 硬件约定

mailbox寄存器组共有128个寄存器，每个寄存器大小为64bit（=8Bytes）。

os应负责将寄存器按如下约定映射到内核地址：

```
1.0-63号寄存器为自己的接收寄存器组：其中0-62号为自己的消息寄存器，自己只能读；63号寄存器为自己的接收区CSR寄存器，自己可读写
2.64-127号寄存器为对方的接收寄存器组：其中64-126号为对方的消息寄存器，自己可以读写；127号寄存器为对方的接收区CSR寄存器，自己可读写
```

对于63号和127号这两组控制寄存器，硬件行为为：

CSR寄存器最高位为中断使能（=0不响应中断/ =1 响应中断）

当该寄存器最高位为1且其他位存在1时（`CSR & 0x 8000_0000_0000_0000 && CSR & 0x7fff_ffff_ffff_ffff `）时，向自己对应的系统发送一个中断，代表接收区有新内容。此时在该位清零前，发送方的下一个中断无法被响应。

当该寄存器最高位为1且其他位全为0时（`CSR & 0x 8000_0000_0000_0000 && !(CSR & 0x7fff_ffff_ffff_ffff) `）时，表示自己处于监听中断状态，发送方可以通过写1来发送中断。

同时，对于自己和别人的CSR写1的行为后果是不一样的。

对于自己的CSR写1，实际上会将写1的位清零，

对于别人的CSR写1，那就是真的写1了

# 发送方（快速轮询）

一次上层msg到来时：

```
剩余消息 = msg
while (剩余消息 ！= 空){
	tail = 接收方buffer的CSR寄存器中的尾指针（代表接收方buffer的尾，对于发送方可读写）
	head = 发送方buffer的CSR寄存器中的头指针（代表接收方buffer的头，对于发送方只读）
	valid_space = tail2head(head, tail) //返回可写字节数 = 寄存器数 * 8
	if  valid_space != 0 {
		if valid_space <= len(剩余消息) { //剩余消息大于等于当前可用空间
			msg_to_write = 剩余消息[:valid_space]
			剩余消息 = 剩余消息[valid_space:] 
			
		} else { //剩余消息小于当前可用空间
			msg_to_write = 剩余消息
			allign (msg_to_write) //将写入的寄存器中的最后一个的结尾补上0（可能有之前的脏数据），按8字节对齐
			剩余消息 = 空
		}
        write(msg_to_write,tail)   //从tail处往内写,写msg_to_write/8个寄存器
        /*等价于发一次中断*/
        tail += BYTES(msg_to_write) / 8  //tail在模意义下增加已使用的格子
        更新对方寄存器buffer中tail字段的值
        发中断
	}
}
```



# 接收方（来一次中断接收一次消息）

当一次中断到来时：

```
开中断
head = 发送方buffer的CSR寄存器中的头指针（代表接收方buffer的头，对于接收方可读写）
tail = 接收方buffer的CSR寄存器中的尾指针（代表接收方buffer的尾，对于接收方只读）
msg = read(head，tail)  //从head指向的寄存器开始读取 head到tail 个寄存器内的内容
将msg传给上层
head = tail
更新自己CSR中head字段的值

```

传出这个片段化的msg
上层根据msg的具体内容进行组装

```
上层组装逻辑待完善。
思路1:在上层消息的传入侧对消息进行包装，加入开始和结束标志，以及自身的标识符
接收方看到的消息类似于：
	【开始标志+发送者id+消息内容part1 , 消息内容part2, ... , 消息内容part_n-1, 消息内容part_n+结束标志】
	（其中逗号代表mailbox两次接收操作间的间隔）
在上层消息的读出侧，通过寻找开始标志与结束标志来将字节流切开

思路2：在上层消息的传入侧对消息进行包装，在mailbox的每一条消息中都加入标头,标头包括(当前任务id，任务的第几个包，任务总共几个包)
接收方看到的消息类似于：
	【标头+消息内容1，标头+消息内容2，...,标头+消息内容n】
在上层消息的读出侧，通过标头信息来收集某个任务的所有包。
```